package services

import (
	"context"
	"time"

	"sheep_farm_backend_go/internal/application/ports"
	"sheep_farm_backend_go/internal/domain"
)

// SheepService provides use cases for sheep management.
// This is an "application service" (use case).
type SheepService struct {
	repo ports.SheepRepository
}

// NewSheepService creates a new SheepService instance.
func NewSheepService(repo ports.SheepRepository) *SheepService {
	return &SheepService{repo: repo}
}

// CreateSheep handles the creation of a new sheep.
func (s *SheepService) CreateSheep(ctx context.Context, sheep *domain.Sheep) error {
	// Add business rules here before persisting
	sheep.ID = "" // ID will be generated by the repository (Firestore)
	sheep.CreatedAt = time.Now()
	sheep.UpdatedAt = time.Now()
	return s.repo.CreateSheep(ctx, sheep)
}

// GetSheepByID retrieves a sheep by its ID.
func (s *SheepService) GetSheepByID(ctx context.Context, userID, sheepID string) (*domain.Sheep, error) {
	return s.repo.GetSheepByID(ctx, userID, sheepID)
}

// GetAllSheep retrieves all sheep for a given user.
func (s *SheepService) GetAllSheep(ctx context.Context, userID string) ([]domain.Sheep, error) {
	return s.repo.GetAllSheep(ctx, userID)
}

// FilterSheep retrieves sheep filtered by gender and age range (in days).
func (s *SheepService) FilterSheep(ctx context.Context, userID string, gender *string, minAgeDays, maxAgeDays *int) ([]domain.Sheep, error) {
	sheepList, err := s.repo.GetAllSheep(ctx, userID)
	if err != nil {
		return nil, err
	}
	var result []domain.Sheep
	now := time.Now()
	for _, sh := range sheepList {
		if gender != nil && sh.Gender != *gender {
			continue
		}
		ageDays := int(now.Sub(sh.DateOfBirth).Hours() / 24)
		if minAgeDays != nil && ageDays < *minAgeDays {
			continue
		}
		if maxAgeDays != nil && ageDays > *maxAgeDays {
			continue
		}
		result = append(result, sh)
	}
	return result, nil
}

// UpdateSheep updates an existing sheep.
func (s *SheepService) UpdateSheep(ctx context.Context, sheep *domain.Sheep) error {
	// Add business rules specific to updating
	existingSheep, err := s.repo.GetSheepByID(ctx, sheep.OwnerUserID, sheep.ID)
	if err != nil {
		return err // Or return domain.ErrNotFound
	}
	if existingSheep.OwnerUserID != sheep.OwnerUserID {
		return domain.ErrUnauthorized // Ensure only owner can update
	}
	sheep.UpdatedAt = time.Now()
	return s.repo.UpdateSheep(ctx, sheep)
}

// DeleteSheep deletes a sheep by its ID.
func (s *SheepService) DeleteSheep(ctx context.Context, userID, sheepID string) error {
	// Add business rules specific to deleting
	return s.repo.DeleteSheep(ctx, userID, sheepID)
}

// AddVaccination appends a vaccination record to the sheep.
func (s *SheepService) AddVaccination(ctx context.Context, userID, sheepID string, v domain.Vaccination) error {
	sh, err := s.repo.GetSheepByID(ctx, userID, sheepID)
	if err != nil {
		return err
	}
	if sh.OwnerUserID != userID {
		return domain.ErrUnauthorized
	}
	sh.Vaccinations = append(sh.Vaccinations, v)
	return s.repo.UpdateSheep(ctx, sh)
}

// AddTreatment appends a treatment record to the sheep.
func (s *SheepService) AddTreatment(ctx context.Context, userID, sheepID string, t domain.Treatment) error {
	sh, err := s.repo.GetSheepByID(ctx, userID, sheepID)
	if err != nil {
		return err
	}
	if sh.OwnerUserID != userID {
		return domain.ErrUnauthorized
	}
	sh.Treatments = append(sh.Treatments, t)
	return s.repo.UpdateSheep(ctx, sh)
}

// AddLambing appends a lambing record to the sheep.
func (s *SheepService) AddLambing(ctx context.Context, userID, sheepID string, l domain.Lambing) error {
	sh, err := s.repo.GetSheepByID(ctx, userID, sheepID)
	if err != nil {
		return err
	}
	if sh.OwnerUserID != userID {
		return domain.ErrUnauthorized
	}
	sh.Lambings = append(sh.Lambings, l)
	return s.repo.UpdateSheep(ctx, sh)
}
